#!/bin/sh
# vi: set ft=sh expandtab shiftwidth=4 tabstop=4:
set -e # the code relies on this, so remove with care
set -u

verbose=1
dry_run=${dry_run-}
help=${help-}

error() { echo "error: $@" >&2 ; }
warn() { echo "warn: $@" >&2 ; }
die() { error "$@" ; exit 1 ; }
verbose() { test "$1" -gt "$verbose" || { shift ; echo "$@" ; } ; }

call() {
    echo "$@"
    if test -z "$dry_run" ; then
        "$@"
    fi
}

do_clone() {
    local rev="$1"
    local remote="$2"
    local co="$3"
	test -d .git_externals || return 1
	local module="$(echo $remote | sed -e 's,\(.*\)\(/trunk\|/branch.*\|/tag.*\),\1,')"
	local branch="$(echo $remote | sed -e 's,\(.*\)\(/trunk\|/branch.*\|/tag.*\),\2,' -e 's,^/,,')"
	if test "$branch" = "$remote" ; then
		branch=""
	fi
 	(
		cd .git_externals
		if test -d "$co" ; then
			(
				cd -- "$co"
				call git svn fetch --all
			)
		else
			tags="tags"
			brch="branches"
			branchpath="$(echo $branch | cut -f1 -d/)"
			echo $tags | grep -- "$branchpath" >/dev/null 2>&1 && tags="$branchpath"
			echo $brch | grep -- "$branchpath" >/dev/null 2>&1 && brch="$branchpath"

			if test "$module" = "$remote" ; then
				# URL does not contains any trunk, branches or tags part, so we dont need
				# additional options for git-svn
				call git svn clone "$rev" "$module" "$co"
			else
				call git svn clone "$rev" "$module" -T trunk -b "$brch" -t "$tags" "$co"
			fi

		fi
		(
			branch="$(echo $branch | sed -e 's,/$,,')"
			if test -n "$branch" ; then
				cd -- "$co"
                dry_run=1
                warn "The following commands might trash your checkout, so I won't run them myself."
                warn "I will only print the commands, and you should verify them and run them yourself."
				echo git reset --hard "$branch"
			fi
		)
	)
}

do_link() {
	local dir="$1"
	local base="$(dirname -- "$dir")"
	(
		mkdir -p -- "$base" >/dev/null 2>&1 || true
		cd -- "$base"
		local rel="$(git rev-parse --show-cdup)"
		ln -sf -- "${rel}.git_externals/$dir"
	)
}

do_excludes() {
	local dir="$1"
	git_excludes_path=.git/info/exclude
	if ! grep -q '^.git_externals$' "$git_excludes_path" ; then
		echo .git_externals >> "$git_excludes_path"
	fi

	if ! grep -q "^$dir\$" "$git_excludes_path" ; then
		echo "$dir" >> "$git_excludes_path"
	fi
}

is_excluded() {
    if test -f .git_externals_exclude ; then
        local matches="$(grep -v "^#" .git_externals_exclude | grep "^/$1$" | wc -l)"
        if test "$matches" -gt 0 ; then
            return 1
        fi
    fi
    return 0
}

is_rev() { echo "$1" | grep -Eq '^r?[0-9]+' ; }
is_url() {
    case "$1" in
    *://*) return 0 ;;
    esac
    return 1
}
categorise() {
    if is_rev "$1" ; then echo "rev"
    elif is_url "$1" ; then echo "url"
    else echo "dir" ; fi
}

main() {
    if test -n "$help" ; then
        usage
        exit 0
    fi
    if test $# -gt 1 ; then
        usage >&2
        exit 1
    fi
    if test $# -eq 1 ; then
        cd -- "$1"
        shift
    fi
    tld="$(git rev-parse --show-cdup)"
    test -n "$tld" && cd -- "$tld"

    git svn show-externals \
      | grep -vE '#|^$' \
      | sed -e 's/\(-r\)[ ]*\([0-9]\{1,\}\)/\1\2/' \
      | while read rev_co rev_url url_co d ; do
        test -n "$rev_co" || continue

        local rev=""
        local url=""
        local co=""

        case "$(categorise "$rev_co")" in
        rev) rev="$rev_co" ;;
        dir) co="$rev_co" ;;
        *) die "$rev_co was expected to be a revision or directory"
        esac

        case "$(categorise "$rev_url")" in
        rev) rev="$rev_url" ;;
        url) url="$rev_url" ;;
        *) die "$rev_url was expected to be a revision or remote URL"
        esac

        case "$(categorise "$url_co")" in
        url) url="$url_co" ;;
        dir) co="$url_co" ;;
        *) die "$url_co was expected to be a remote URL or directory"
        esac

        if test -n "$extra" ; then
            warn "Unknown extra data from 'git svn show-externals': $extra"
        fi
        unset url_co rev_url rev_co extra

        # XXX these error messages could be improved
        if test -z "$url" ; then
            die "URL field is empty"
        fi
        if test -z "$co" ; then
            die "Directory field is empty"
        fi

        if ! is_excluded "$co" ; then
            if test -n "${USE_SSH-}" ; then
                verbose 1 "Rewriting URL to use svn+ssh"
                url="$(perl -we 'ARGV[1]=~s,^(http|https)://,svn+ssh://,;print "$ARGV[1]\n";' "$url")"
            fi

            verbose 1 "$co -> $url"

            local baseco="$(dirname -- "$co")"
            if ! test -d ".git_externals/$baseco" ; then
                verbose 1 "Creating .git_externals"
                mkdir -p ".git_externals/$baseco"
            fi

            do_clone "$rev" "$url" "$co" || exit
            do_link "$co"
            do_excludes "$co"
        fi
    done
}
trap 'echo Caught SIGINT >&2 ; exit 1 ;' INT
trap 'echo Caught SIGTERM >&2 ; exit 1 ;' TERM
main "$@"
